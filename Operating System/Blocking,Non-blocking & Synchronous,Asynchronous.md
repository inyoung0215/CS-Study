# Blocking/Non-blocking & Synchronous/Asynchronous

## Blocking?
- 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 다른 작업이 끝날 때까지 기다렸다가 자신의 작업을 시작하는 것을 의미합니다.

## Non-blocking?
- 다른 주체의 작업에 관련없이 자신의 작업을 하는 것을 의미합니다.

## Synchronous?
- 호출하는 함수가 해당 작업의 결과 값을 받아서 다음 작업을 수행합니다.

## Asynchronous?
- 호출하는 함수가 작업 완료 여부를 신경 쓰지 않는다.
- Asynchronous를 구현하기 위해 호출된 함수의 작업은 별도의 thread로 빼서 실행하며 완료되면, 호출한 함수에게 알려준다.
- 호출하는 함수에게 Callback을 전달해서 작업을 완료하면 실행하도록 한다.

## Sync-Blocking & Async-Nonblocking
![image](https://github.com/inyoung0215/CS-Study/assets/84082544/ebabbcca-5b5c-4759-8aaa-9ab479b27db7)
- Sync-Blocking 은 호출된 함수의 리턴을 계속 기다립니다.
```
나 : 치킨 한마리만 포장해주세요.
사장님 : 네 잠시만요.
-- 치킨 튀기는 중--
나 : (서서 치킨 튀기는거 보면서 기다림)
```

- Async-Nonblocking 은 호출된 함수의 작업 완료 및 리턴을 기다리지 않습니다
```
나 : 치킨 한마리만 포장해주세요.
사장님 : 네
-- 치킨 튀기는 중--
나 : (앉아서 다른 일 하는 중)
...
사장님 : 치킨 나왔습니다
나 : 감사합니다.
```

## Sync-Nonblocking
![image](https://github.com/inyoung0215/CS-Study/assets/84082544/a9ef1210-b62b-4577-bfe1-b72385fb0a2e)
- 동기적으로 실행되지만 논블로킹이기 때문에 제어권은 바로 반환받게 되는 구조입니다.
- 동기적으로 돌기 때문에 호출한 함수는 호출된 함수의 작업 완료 여부, 결과값 반환에 관심을 가지게 됩니다.
- 논블로킹으로 인해 제어권을 바로 반환받아 다른 작업을 할 수 있음에도 동기적으로 돌기 때문에 호출된 함수의 완료 여부를 계속해서 문의하게 됩니다.
```
나 : 치킨 한마리만 포장해주세요.
사장님 : 시간이 좀 걸려서 다른 일 보시다 오세요.
-- 치킨 튀기는 중--
(5분뒤) 나 : 나왔나요?
사장님 : 아직이요
(5분뒤) 나 : 나왔나요?
사장님 : 아직이요
```

## Async-Blocking
![image](https://github.com/inyoung0215/CS-Study/assets/84082544/55b11da8-72fd-478d-a481-d2720a7a2bb1)
- 비동기 블로킹 함수는 비동기 이기 때문에 호출된 함수의 결과에는 관심이 없지만, 블로킹 구조로 제어권을 가지지 못하기 때문에 호출된 함수의 작업이 완료될 때까지 대기하게 됩니다. 
- 호출된 함수의 작업이 끝나고 콜백함수가 호출되어 결과가 반환되고 나면 대기하고 있던 작업 함수를 호출한 함수는 다음 작업을 수행하게 됩니다.
- 사실상 이점이 없는 방식이기 때문에 잘 구현하지 않는다고 합니다. 주로 Async-NonBlocking 구조를 구현하려다가 제어권을 잘 반환하지 못해서 Async-Blocking 으로 동작하는 경우가 종종 있다고 합니다.
```
나 : 사장님 치킨 한마리만 포장해주세요.
사장님 : 잠시만요
-- 사장님 치킨 튀기는 중--
나 : (언제 되는지 안 궁금한데 잠시만이래서 다 될 때까지 서서 기다리는 중)
```

### Reference
- [Sync - Async / Blocking - Non-Blocking](https://jammdev.tistory.com/168)
