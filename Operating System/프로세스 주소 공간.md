# 프로세스 주소 공간(Process Address Space)

프로그램이 실행되면 프로세스가 생성되고 메모리에 '프로세스 주소 공간'이 할당(생성) 된다.

이렇게 할당 된 process를 CPU가 실행시키게 된다.

![image](https://github.com/inyoung0215/CS-Study/assets/65496092/b2905bb8-3b84-4412-99d7-6f33a033b7c9)

# 주소 공간 구성 요소 
![image](https://github.com/inyoung0215/CS-Study/assets/65496092/11371d66-15b3-4179-a262-dca5b89a5e07)

## Code(Text) 영역
- 프로그램이 실행될 수 있도록 CPU가 해석 가능한 **기계어 코드** 가 저장되어 있는 공간
- 컴파일 시에 크기가 결정된다.
- 프로그램의 코드는 수정되면 안되므로, Read-Only 로 지정되어있다.
- 같은 프로그램으로 실행된 여러 프로세스는 동일한 코드를 가진다.
- 동일한 내용을 중복 할당하지 않고 하나의 공간으로 구성하여 메모리 사용량을 절약할 수 있다.

## Data 영역
- 초기값이 있는 전역/static(정적) 변수, 초기화된 상수 등이 저장되는 공간이다.
- 전역/static 변수를 참조한 코드는 컴파일 후 Data 영역의 주소값을 가리킨다.
- 한 프로세스 내 여러 스레드가 공통으로 Data 영역을 공유한다.
- 중복된 내용을 여러 번 할당하지 않고 하나의 공간으로 구성하여 메모리 사용량을 절약할 수 있다.
- 실행 중에 변수가 수정될 수 있기에 Read-Write 로 지정되어있다.
- 프로그램 실행 시 생성되고, 프로그램 종료 시 소멸된다.

## BSS(Block Stated Symbol) 영역
- 초기값이 없는 전역/static(정적) 변수가 저장되는 공간이다.
- BSS 영역은 초기화되지 않은 변수를 저장하기 위한 것이며, 해당 변수들은 0 또는 NULL 값으로 초기화된다.
- 실행 중에 변수가 수정될 수 있기에 Read-Write 로 지정되어있다.
- 프로그램 실행 시 생성되고, 프로그램 종료 시 소멸된다.

## Stack 영역
- 함수의 실행을 마치고 복귀할 주소, 데이터(지역 변수, 매개 변수, 반환값)를 임시로 저장하는 공간이다.
- 각 함수는 LIFO 구조로 실행된다.
- 컴파일 시 크기가 결정된다.
- 재귀 함수가 너무 깊게 호출되거나(함수를 반환하지 않고 계속해서 쌓거나) 지역변수가 많아지면 Stack Overflow가 발생할 수 있다.
- 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.
- 실행 중에 변수가 수정될 수 있기에 Read-Write 로 지정되어있다.
- 함수의 호출과 함께 할당되고, 함수 호출 완료 시 소멸된다.

## Heap 영역
- 동적 할당(malloc(), new 등)을 위한 메모리 영역이다.
- 프로그래머가 User mode에서 직접 제어할 수 있는 영역이다.
- 런타임에 크기가 정해진다.
- 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.
- 주로 참조형 데이터(ex. 객체, 클래스 인스턴스) 등의 데이터가 할당된다.

💡 참고 

Heap과 Stack은 물리적 메모리에서 같은 공간을 공유하며, 서로 다른 방향으로 확장된다. 

일반적으로 Heap은 상위 주소에서 아래로 확장되고, Stack은 하위 주소에서 위로 확장된다.

이렇게 서로 다른 방향으로 확장되는 구조 때문에 Heap 영역과 Stack 영역이 서로 침범할 수 있으며, 이러한 경우를 각각 Heap Overflow와 Stack Overflow라고 부른다.

# +) 스레드 주소 공간
![image](https://github.com/inyoung0215/CS-Study/assets/65496092/c5095f87-6e76-463e-8ee5-e2f843e37f09)
- 멀티 스레드 상황에서 같은 프로세스 내의 모든 스레드는 Code, Data, Heap 영역을 공유한다.
- Stack 영역은 공유하지 않고 스레드별로 할당받는다.
- 자원을 공유하기에 동기화 문제가 발생할 수 있다.

# ✏️ 관련 질문
## Q1. 왜 Code 부분을 따로 두었나? (Why OS separates code segment?)
Program의 Code는 Program이 만들어지고(컴파일되고) 나서는 바뀔 일이 전혀 없기 때문에 읽기만 가능한 Read Only 부분입니다. 

같은 프로그램을 실행시켜 여러 Prcess가 실행되더라도 같은 프로그램이라면 Code 부분은 다 똑같은 내용을 가지고 있게 됩니다. 

따라서 같은 Program의 Process일 경우 Code 부분을 공유(Share)하여 메모리 사용량을 줄이는 목적입니다.

## Q2. 왜 Stack 부분과 Data 부분을 나누었나? (Why Os separates stack from data segment?)
Stack과 Data 영역의 분리는 메모리 관리, 함수 호출 관리, 보안, 안정성 등 다양한 측면에서 중요한 역할을 합니다.

Stack 영역은 함수 호출과 로컬 변수 관리를 위한 공간으로, 각 함수의 실행 흐름을 독립적으로 관리합니다. 

이는 스레드와 같은 병렬 실행 단위에서 각각의 스택을 갖게 하여 함수 호출을 격리시키는 데 도움을 줍니다.

Data 영역은 전역 변수와 정적 변수를 저장하는 공간으로, 이러한 변수들은 프로그램 전체에서 공유됩니다. 

따라서 스레드 간에 Data 영역을 공유함으로써 메모리 효율을 높이고 중복된 내용을 공유하여 메모리 사용량을 절약합니다.

이렇게 Stack과 Data 영역을 분리하여 관리함으로써 프로그램의 실행을 효율적으로 제어하고 메모리 관리를 간소화할 수 있으며, 동시에 스레드와 같은 병렬 실행 환경에서 안전한 실행을 보장합니다.

💡 함수의 실행과 Stack 구조
![image](https://github.com/inyoung0215/CS-Study/assets/65496092/15e88377-8b33-4239-a3cd-946667782099)
![image](https://github.com/inyoung0215/CS-Study/assets/65496092/f5ef6c8e-be02-4b76-be63-0666fd0791a5)

## Q3. Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?
다음과 같은 이유로 Stack 공간이 더 빠릅니다. 

- 할당 및 해제 속도
  - 스택에서 할당의 의미는 이미 생성되어 있는 스택에 대해 포인터의 위치만 바꿔주는 단순한 CPU Instruction(덧셈과 뺄셈 연산, 일반적으로 단일 Instruction)이다. 
  - 반면 힙에서의 할당은 요청된 chunk의 크기, 현재 메모리의 fragmentation 상황 등 다양한 요소를 고려하기 때문에 더 많은 CPU Instruction이 필요하다.

- 메모리 지역성
  - 스택은 함수 호출과 로컬 변수 관리를 위한 영역으로 사용되며, 스택 프레임은 주로 현재 실행 중인 함수와 관련된 데이터만을 포함하므로 메모리 지역성(locality)이 높다. 
  - 이로 인해 데이터가 CPU 캐시를 하기에 더 잘 어울려 빠른 메모리 액세스가 가능합니다.

- 간단한 구조
  - 스택은 LIFO 구조를 가지며, 각 함수의 호출 및 반환 정보를 스택에 단순하게 쌓고 제거합니다. 
  - 이러한 구조로 인해 함수 호출 및 반환이 간단하게 이루어지며, 메모리 관리가 효율적입니다.

>Reference <br></br>
>[프로세스(Process)의 주소 공간(Address Space)](https://whereisusb.tistory.com/10) <br></br>
>[Process Address Space(프로세스 주소 공간)](https://hojunking.tistory.com/51) <br></br>
>[[운영체제] 프로세스 주소공간](https://velog.io/@klloo/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A3%BC%EC%86%8C%EA%B3%B5%EA%B0%84) <br></br>