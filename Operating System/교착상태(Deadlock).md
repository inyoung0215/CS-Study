# 교착상태(DeadLock)

## DeadLock?
DeadLock 이란 상호 배제에 의해 나타나는 문제점으로, 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상을 의미합니다.

![img.png](img.png)
- 위의 그림과 같이 자동차(프로세스)들이 각각의 도로(자원)를 점유한 상태에서 다른 자동차(프로세스)들이 사용하고 있는 도로(자원)를 사용하기 위해 대기하고 있지만, 도로 위에서 이러지도 저러지도 못하는 상황을 예시로 들 수 있겠습니다.

![img_1.png](img_1.png)
- 위의 그림은 개발 환경에서 교착상태를 보여주는 그림입니다.

## DeadLock 의 발생 조건 4가지
교착상태는 아래의 4가지 조건이 모두 만족되는 경우에 발생할 가능성이 있으며,
하나라도 만족하지 않으면 교착상태가 발생하지 않습니다.

### 상호 배제(Mutual Exclusion)
- 한 리소스는 한 번에 한 프로세스만이 사용할 수 있다.
### 점유 대기(Hold and Wait)
- 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다림
### 비선점(No Preemption)
- 이미 할당된 자원을 강제로 빼앗을 수 없다.
- 프로세스가 처리를 마친 후 리소스를 자발적으로 반환할 때까지 기다려야 한다.
### 순환 대기(Circular Wait)
- 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.

## DeadLock 해결 방법 4가지
### 예방 (Prevention)
- 교착상태가 일어날 상황 자체를 미연에 방지하는 것이다.
- 상호 배제 부정
    - 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다.
- 점유 대기 부정
    - 프로세스가 실행되기 전 필요한 모든 자원을 할당한다.
- 비선점 부정
    - 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고 요구한 자원을 사용하기 위해 기다리게 한다.
- 순환 대기 부정
    - 자원에 고유한 번호를 할당하고 번호 순서대로 자원을 요구하도록 한다.
- 단점: 자원 낭비가 심하다.
### 회피 (Avoidance)
- 교착 상태가 발생하면 피해가는 방법
- 은행원 알고리즘
    - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사해서 교착 상태를 회피한다.
안정 상태면 자원 할당하고 아니면 다른 프로세스들이 자원을 해지하기까지 대기한다.
    - 최대 자원의 요구량을 미리 알아야하며(하지만 프로그램은 정확하게 15의 자원을 요구하지 않는다.), 자원 이용도가 낮거나 유한한 시간내로 자원을 사용 후 반납하여야 하는 문제점으로 인해 현재 운영체제에 사용되지는 않는다.
### 탐지 (Detection)
- 자원 할당 그래프를 통해 교착 상태를 탐지한다.
### 복구 (Recovery)
- 교착 상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법
- 프로세스 종료 방법
- 자원 회수
  - 프로세스에 할당된 각 자원들을 데드락 현상이 사라질 때까지 강제로 회수하는 방법이다. 주로 운영체제 수준에서만 가능하다.


### Reference
- [데드락 - 나무위키](https://namu.wiki/w/%EB%8D%B0%EB%93%9C%EB%9D%BD)
